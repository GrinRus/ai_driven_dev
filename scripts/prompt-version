#!/usr/bin/env python3
"""Manage prompt versions across locales."""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Dict, List, Tuple

PROMPT_DIRS = {
    "agent": {
        "ru": Path(".claude/agents"),
        "en": Path("prompts/en/agents"),
    },
    "command": {
        "ru": Path(".claude/commands"),
        "en": Path("prompts/en/commands"),
    },
}


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Prompt version manager")
    sub = parser.add_subparsers(dest="command", required=True)

    bump = sub.add_parser("bump", help="Increase prompt_version")
    bump.add_argument("--root", type=Path, default=Path(__file__).resolve().parents[1])
    bump.add_argument(
        "--prompts",
        default="all",
        help="Comma-separated prompt names or 'all'",
    )
    bump.add_argument(
        "--kind",
        choices=("agent", "command", "both"),
        default="both",
        help="Prompt kind(s) to update",
    )
    bump.add_argument(
        "--lang",
        default="ru,en",
        help="Comma-separated locales to bump (ru,en)",
    )
    bump.add_argument(
        "--part",
        choices=("major", "minor", "patch"),
        default="patch",
        help="Which version segment to increment",
    )
    bump.add_argument("--dry-run", action="store_true")
    return parser.parse_args()


def list_prompts(root: Path, kind: str) -> List[str]:
    ru_dir = root / PROMPT_DIRS[kind]["ru"]
    if not ru_dir.exists():
        return []
    return sorted(p.stem for p in ru_dir.glob("*.md"))


def parse_version(value: str) -> Tuple[int, int, int]:
    try:
        major, minor, patch = (int(part) for part in value.split("."))
    except ValueError:
        raise ValueError(f"invalid version '{value}'")
    return major, minor, patch


def bump_version(value: str, part: str) -> str:
    major, minor, patch = parse_version(value)
    if part == "major":
        major += 1
        minor = patch = 0
    elif part == "minor":
        minor += 1
        patch = 0
    else:
        patch += 1
    return f"{major}.{minor}.{patch}"


def update_front_matter(path: Path, updates: Dict[str, str], dry_run: bool) -> None:
    lines = path.read_text(encoding="utf-8").splitlines()
    if not lines or lines[0].strip() != "---":
        raise ValueError(f"{path}: missing front matter")
    try:
        closing = lines.index("---", 1)
    except ValueError as exc:  # pragma: no cover - invalid files caught elsewhere
        raise ValueError(f"{path}: unterminated front matter") from exc
    for key, value in updates.items():
        found = False
        for idx in range(1, closing):
            if lines[idx].strip().startswith(f"{key}:"):
                old = lines[idx]
                lines[idx] = f"{key}: {value}"
                found = True
                break
        if not found:
            lines.insert(closing, f"{key}: {value}")
            closing += 1
    new_text = "\n".join(lines) + "\n"
    if dry_run:
        print(f"[prompt-version] dry-run: would update {path}")
    else:
        path.write_text(new_text, encoding="utf-8")


def load_front_matter(path: Path) -> Dict[str, str]:
    front: Dict[str, str] = {}
    lines = path.read_text(encoding="utf-8").splitlines()
    if not lines or lines[0].strip() != "---":
        raise ValueError(f"{path}: missing front matter")
    closing = lines.index("---", 1)
    for raw in lines[1:closing]:
        if ":" not in raw:
            continue
        key, value = raw.split(":", 1)
        front[key.strip()] = value.strip().strip('"').strip("'")
    return front


def ensure_exists(path: Path) -> None:
    if not path.exists():
        raise FileNotFoundError(path)


def bump(args: argparse.Namespace) -> int:
    root: Path = args.root
    kinds = ["agent", "command"] if args.kind == "both" else [args.kind]
    languages = [lang.strip() for lang in args.lang.split(",") if lang.strip()]
    prompts_requested = None if args.prompts == "all" else [p.strip() for p in args.prompts.split(",")]
    for kind in kinds:
        available = list_prompts(root, kind)
        targets = available if prompts_requested is None else prompts_requested
        missing = [name for name in targets if name not in available]
        if missing:
            raise SystemExit(f"{kind} prompts not found: {', '.join(missing)}")
        for name in targets:
            ru_path = root / PROMPT_DIRS[kind]["ru"] / f"{name}.md"
            front = load_front_matter(ru_path)
            current_version = front.get("prompt_version") or "0.0.0"
            new_version = bump_version(current_version, args.part)
            updates_ru = {"prompt_version": new_version, "source_version": new_version}
            update_front_matter(ru_path, updates_ru, args.dry_run)
            print(f"[prompt-version] {ru_path}: {current_version} -> {new_version}")

            ru_ref_version = new_version
            if "en" in languages:
                en_path = root / PROMPT_DIRS[kind]["en"] / f"{name}.md"
                ensure_exists(en_path)
                en_front = load_front_matter(en_path)
                en_current = en_front.get("prompt_version") or "0.0.0"
                updates_en = {"prompt_version": new_version, "source_version": ru_ref_version}
                update_front_matter(en_path, updates_en, args.dry_run)
                print(f"[prompt-version] {en_path}: {en_current} -> {new_version}")
            else:
                # still ensure EN source_version matches new RU version to keep parity reminders useful
                en_path = root / PROMPT_DIRS[kind]["en"] / f"{name}.md"
                if en_path.exists():
                    update_front_matter(en_path, {"source_version": ru_ref_version}, args.dry_run)
                    print(f"[prompt-version] {en_path}: source_version -> {ru_ref_version}")
    return 0


def main() -> int:
    args = parse_args()
    if args.command == "bump":
        return bump(args)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
