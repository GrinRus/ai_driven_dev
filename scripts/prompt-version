#!/usr/bin/env python3
from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Dict


def parse_frontmatter(text: str) -> Dict[str, str]:
    lines = text.splitlines()
    if not lines or lines[0].strip() != "---":
        return {}
    data: Dict[str, str] = {}
    for line in lines[1:]:
        if line.strip() == "---":
            break
        if ":" not in line:
            continue
        key, value = line.split(":", 1)
        data[key.strip()] = value.strip()
    return data


def replace_field(text: str, key: str, value: str) -> str:
    lines = text.splitlines()
    replaced = False
    for idx, line in enumerate(lines):
        if line.startswith(f"{key}:"):
            lines[idx] = f"{key}: {value}"
            replaced = True
            break
    if not replaced:
        insert_at = 1 if len(lines) > 1 else len(lines)
        lines.insert(insert_at, f"{key}: {value}")
    return "\n".join(lines) + ("\n" if text.endswith("\n") else "")


def bump_version(version: str, part: str) -> str:
    major, minor, patch = (int(x) for x in version.split("."))
    if part == "minor":
        minor += 1
        patch = 0
    else:
        patch += 1
    return f"{major}.{minor}.{patch}"


def resolve_ru_base(root: Path, kind: str) -> Path:
    subdir = "agents" if kind == "agent" else "commands"
    candidates = [
        root / subdir,
        root / "aidd" / subdir,
        root / ".claude" / subdir,
    ]
    for candidate in candidates:
        if candidate.exists():
            return candidate
    return candidates[0]


def resolve_en_base(root: Path, kind: str) -> Path:
    subdir = "agents" if kind == "agent" else "commands"
    candidates = [
        root / "prompts" / "en" / subdir,
        root / "aidd" / "prompts" / "en" / subdir,
    ]
    for candidate in candidates:
        if candidate.exists():
            return candidate
    return candidates[0]


def process_prompt(
    root: Path, name: str, kind: str, langs: set[str], part: str, *, dry_run: bool
) -> int:
    ru_base = resolve_ru_base(root, kind)
    en_base = resolve_en_base(root, kind)
    ru_path = ru_base / f"{name}.md"
    en_path = en_base / f"{name}.md"
    if not ru_path.exists():
        print(f"[prompt-version] RU prompt missing: {ru_path}", file=sys.stderr)
        return 1

    ru_text = ru_path.read_text(encoding="utf-8")
    ru_meta = parse_frontmatter(ru_text)
    ru_version = ru_meta.get("prompt_version", "0.0.0")
    new_version = bump_version(ru_version, part)
    lang_parity_skip = ru_meta.get("Lang-Parity", "").lower() == "skip"

    if "ru" in langs:
        ru_text = replace_field(ru_text, "prompt_version", new_version)
        ru_text = replace_field(ru_text, "source_version", new_version)

    if en_path.exists():
        en_text = en_path.read_text(encoding="utf-8")
        if "en" in langs:
            en_text = replace_field(en_text, "prompt_version", new_version)
            en_text = replace_field(en_text, "source_version", new_version)
        elif "ru" in langs:
            en_text = replace_field(en_text, "source_version", new_version)
        if not dry_run:
            en_path.write_text(en_text, encoding="utf-8")
    elif "en" in langs and not lang_parity_skip:
        print(f"[prompt-version] EN prompt missing: {en_path}", file=sys.stderr)
        return 1

    if not dry_run:
        ru_path.write_text(ru_text, encoding="utf-8")
    return 0


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Bump prompt_version/source_version for prompts.")
    subparsers = parser.add_subparsers(dest="command", required=True)
    bump = subparsers.add_parser("bump", help="Bump prompt versions for selected prompts.")
    bump.add_argument("--root", required=True, help="Workflow root containing agents/commands and prompts/en.")
    bump.add_argument("--prompts", required=True, help="Comma-separated prompt names.")
    bump.add_argument("--kind", choices=("agent", "command"), required=True)
    bump.add_argument("--lang", default="ru,en", help="Comma-separated languages to bump (default: ru,en).")
    bump.add_argument("--part", choices=("patch", "minor"), default="patch", help="Version part to bump.")
    bump.add_argument("--dry-run", action="store_true", help="Calculate new versions without writing files.")

    args = parser.parse_args(argv)
    if args.command == "bump":
        root = Path(args.root).resolve()
        prompts = [p.strip() for p in args.prompts.split(",") if p.strip()]
        langs = {lang.strip() for lang in args.lang.split(",") if lang.strip()}
        for name in prompts:
            rc = process_prompt(root, name, args.kind, langs, args.part, dry_run=args.dry_run)
            if rc != 0:
                return rc
        return 0
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
